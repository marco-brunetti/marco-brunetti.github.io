<p>
    Novedades en SLSL 
    © 2003 Juan Segovia (jsegovia@cnc.una.py)
    Este es un resumen de las extensiones y mejoras que se han incorporado en SL
    recientemente. Estas adiciones simplifican y facilitan la escritura de los programas y brindan
    nuevas funcionalidades, las que benefician tanto al docente como al estudiante de
    fundamentos de programaciÛn.
    Lo que sigue es una lista parcial de las novedades:
     Las variables pueden ser inicializadas al tiempo que se las declara.
     En la mayorÌa de los casos, el tipo de las variables puede ser omitido en su declaraciÛn si se
    asigna un valor inicial.
     Es posible salir anticipadamente de los ciclos con la sentencia ìsalirî.
     Los registros y arreglos pueden ser leÌdos e impresos con una sola llamada a ìleerî o
    ìimprimirî. Los valores lÛgicos (booleanos) tambiÈn pueden ser leÌdos, adem·s de impresos.
     El intento de leer m·s datos cuando ya no est·n disponibles porque se llegÛ al final del archivo
    no genera un error de ejecuciÛn; simplemente en tal caso basta con verificar el valor de retorno
    de la funciÛn eof().
     Es posible recuperar un car·cter a la vez por cada llamada a leer().
     El cursor puede ser posicionado en cualquier parte de la pantalla antes de realizar una lectura o
    impresiÛn.
     Se puede cambiar el color de fondo y de primer plano de los caracteres impresos en la pantalla.
     Se agregÛ una funciÛn que emite un pitido con una frecuencia y duraciÛn dadas.
     Es posible averiguar la cantidad de columnas y de lÌneas de la pantalla.
     La palabra ìsubî se considera sinÛnimo de ìsubrutinaî.
     Los n˙meros pueden llevar un guiÛn bajo entre sus dÌgitos, para facilitar la lectura.
     Ya no es obligatorio el uso de parÈntesis en la expresiÛn que sigue a la sentencia ìretornaî.
     La ejecuciÛn del programa SL se puede terminar con la subrutina ìterminar()î
     Los operadores lÛgicos && (and) y || (or) implementan evaluaciÛn en modo ìcorto-circuitoî, lo
    que puede facilitar la escritura de ciertos ciclos.
     Se agregÛ una funciÛn para ejecutar programas externos.
     Se agregaron las funciones min() y max().
    A continuaciÛn se explica con m·s detalles algunas de estas novedades.
    1.1. SIMPLIFICACI”N DE LA DECLARACI”N DE VARIABLESSIMPLIFICACI”N DE LA DECLARACI”N DE VARIABLES
    La nueva sintaxis para inicializar las variables al declararlas puede utilizarse cuando se
    conoce de antemano el valor inicial, o simplemente como una manera m·s compacta de
    escribir el programa.
    P·gina 1/14
    NÛtese que el compilador deduce el tipo de las variables del tipo de la expresiÛn que se
    utiliza para inicializarlas. Es decir, si el inicializador es “Buen día” por ejemplo, la variable
    ser· del tipo ìcadenaî. Una vez identificado el tipo de dato, el compilador de SL sigue
    realizando todos los chequeos de compatibilidad habituales.
    Ejemplo 1: Imprimir los primeros 10 tÈrminos de la serie de Fibonacci de orden 2.
    1. var
    2. a = 0
    3. b = 1
    4. num_term = 2
    5.
    6. /*
    7. * Como el valor de la variable c es cambiado por cada iteración,
    8. * no vale la pena asignarle un valor al declararla, aunque
    9. * no hay problemas en hacerlo.
    10. */
    11. c : numerico
    12. inicio
    13. imprimir (a, ' ', b)
    14. mientras ( num_term < 10 ) {
    15. c = a + b
    16. imprimir (' ', c)
    17. a = b
    18. b = c
    19. inc (num_term)
    20. }
    21. fin
    El inicializador puede ser un valor simple, como en el ejemplo previo, o podrÌa ser una
    expresiÛn m·s compleja que involucre a otras variables previamente declaradas o funciones.
    Por ejemplo:
    1. /*
    2. * Observacion: Este no es un programa SL completo. Solo muestra
    3. * cómo el inicializador puede ser una expresión compleja.
    4. */
    5.
    6. sub mostar_simplif (a, b : numerico) retorna cadena
    7. var
    8. m = mcd (a, b)
    9. res = ""
    10. inicio
    11. res = str(a/m, 0, 0) + "/" str(b/m, 0, 0)
    12. ...
    13. fin
    14.
    15.
    16. sub mcd (a, b : numerico) retorna numerico
    17. /*
    18. * Calcula el MCD de dos numeros, que deben ser enteros positivos.
    19. */
    20. inicio
    21. mientras ( a <> b ) {
    22. si ( a > b ) {
    23. a = a % b
    24. sino
    25. b = b % a
    26. }
    27. }
    28. retorna a
    29. fin
    P·gina 2/14
    Ejemplo 2: Mediante una funciÛn, asociar un entero (1-7) al nombre de un dÌa de la
    semana que se pasa como par·metro.
    1. sub identificar_dia (dia : cadena) retorna numerico
    2. var
    3. nom_dias : vector [*] cadena = {“dom”, “lun”, “mar”, “mie”,
    4. “jue”, “vie”, “sab”
    5. }
    6. /*
    7. * num_dia contendrá el numero de dia (1-7). Retorna 0 si parámetro no
    8. * corresponde a un día de la semana.
    9. */
    10. num_dia = 0
    11. k = 0
    12. inicio
    13. /*
    14. * Se consideran solo los primeros 3 caracteres del parámetro dia.
    15. * Para facilitar la comparación, el nombre del día se pasa a minúsculas,
    16. * pues nom_dias contiene caracteres en minúsculas.
    17. */
    18. dia = lower(substr (dia, 1, 3))
    19. desde k=1 hasta alen(nom_dias) {
    20. si ( nom_dias [k] == dia ) {
    21. num_dia = k
    22. salir
    23. }
    24. }
    25. retorna num_dia
    26. fin
    En este ejemplo, es necesario especificar el tipo de nom_dias antes de asignar los valores
    porque de lo contrario el compilador no podrÌa completar algunas verificaciones, entre ellas
    que todos los elementos del arreglo sean del mismo tipo.
    2.2. SALIDAS ANTICIPADAS DE LOS CICLOSSALIDAS ANTICIPADAS DE LOS CICLOS
    Usando salir, que es una palabra reservada a partir de ahora, se puede terminar la
    ejecuciÛn de un ciclo (mientras, repetir..hasta y desde) sin que se haya
    cumplido la condiciÛn de salida.
    Ejemplo: Leer una serie de n˙meros positivos y almacenarlos en un vector.
    1. sub leer_num_positivos (cant : numerico;
    2. ref A : vector [*] numerico) retorna numerico
    3. /*
    4. * leer_num_positivos() lee sucesivamente una serie de
    5. * numeros y los deposita en un vector.
    6. *
    7. * Para de leer cuando:
    8. * a. Ya se leyeron cant numeros, o
    9. * b. Se llenaron las posiciones del vector, o
    10. * c. Se ingresa un numero negativo, el cual NO se almacena
    11. * en el vector.
    12. *
    13. * RETORNA
    14. * La cantidad de numeros leidos y almacenados en el vector.
    15. */
    16. var
    17. k = 0
    18. cant_leidos = 0
    P·gina 3/14
    19. inicio
    20. desde k=1 hasta min (cant, alen (A)) {
    21. imprimir (" Ingrese valor [", k, "]: ")
    22. leer (A [k])
    23. /*
    24. * Salir si el numero leido es negativo.
    25. */
    26. si ( A [k] < 0 ) {
    27. salir
    28. }
    29. inc (cant_leidos)
    30. }
    31. retorna cant_leidos
    32. fin
    El uso de salir podrÌa simplificar el cÛdigo en ciertos casos, especialmente cuando se
    usan variables lÛgicas adicionales solo para controlar la salida anticipada de ciclos. Sin
    embargo, se recomienda utilizarlo con mesura, pues los programas pueden ser difÌciles de
    comprender a causa de su uso excesivo.
    3.3. LECTURA E IMPRESI”N DE DATOS ESTRUCTURADOSLECTURA E IMPRESI”N DE DATOS ESTRUCTURADOS
    Para acortar la escritura de programas, se dotÛ a leer() e imprimir() de la capacidad
    de operar sobre datos estructurados, como ser arreglos y registros. AsÌ, con una sola
    llamada a una de estas subrutinas es posible aceptar o mostrar varios datos.
    Por ejemplo, si se est· procesando un archivo cuyos registros contienen datos de un
    alumno (nombre, fecha de nacimiento, carrera y curso actual), una variaciÛn de lo que se
    muestra a continuaciÛn puede usarse para recuperar cada registro con un solo leer().
    1. /*
    2. * Observacion: Este no es un programa SL válido. Solo muestra las
    3. * nuevas características consideradas.
    4. */
    5. var
    6. reg : registro {
    7. nombre : cadena
    8. fecha_nac : numerico // AAAAMMDD
    9. cod_carrera : cadena
    10. curso_actual : numerico
    11. notas_semestre : vector [5] numerico
    12. }
    13. inicio
    14. leer (reg)
    15. mientras ( not eof() ) {
    16. ...
    17. ...
    18. leer (reg)
    19. }
    20. fin
    Cada operaciÛn de leer() esperar· a que se ingresen en total 9 datos (4 + 5 notas), como
    si hubiesen sido leÌdos cada uno independientemente. Cada valor debe estar separado del
    siguiente por el car·cter coma, o por lo que se haya configurado vÌa la subrutina
    predefinida set_ifs().
    Por otra parte, puede usarse imprimir()para desplegar todo el registro, o un arreglo,
    P·gina 4/14
    independientemente de la cantidad de dimensiones. Suponga que desea desplegar las notas
    de un alumno en particular, donde cada nota se muestre en una lÌnea independiente. Para
    ello puede utilizar el siguiente cÛdigo:
    1. /*
    2. * Observación: Código incompleto; solo muestra el uso de set_ofs() e
    3. * imprimir() con datos estructurados.
    4. */
    5. ...
    6. set_ofs ("\n")
    7. imprimir (reg.notas_semestre)
    8. ...
    AquÌ puede verse el uso de la nueva funciÛn set_ofs(), que sirve para indicar quÈ
    car·cter utilizar· imprimir() para separar los elementos cuando se le pasa para imprimir
    un arreglo completo o un registro. Vea m·s adelante detalles adicionales sobre
    set_ofs() que pueden resultarle de utilidad.
    Como parte de esta ampliaciÛn, SL tiene actualmente la capacidad de leer datos del tipo
    logico. Se considera que ìSIî y ìTRUEî (tipeados en may˙sculas, en min˙sculas o en
    cualquier combinaciÛn) corresponden al valor lÛgico ìverdaderoî, mientras que ìNOî y
    ìFALSEî, igualmente en cualquier combinaciÛn de may˙sculas/min˙sculas, corresponden a
    ìfalsoî.
    4.4. CONTROL SOBRE EL CURSOR, EL COLOR Y OTROSCONTROL SOBRE EL CURSOR, EL COLOR Y OTROS
    Fueron agregadas varias funciones para controlar el color con el que se mostrar·n los datos
    impresos, asÌ como para cambiar la posiciÛn del cursor, para la lectura de teclas con un
    tiempo m·ximo de espera, la emisiÛn de pitidos, entre otros. En su conjunto, estas nuevas
    funciones posibilitan escribir programas m·s vistosos e interactivos.
    Estas adiciones tienen como objetivo dar soporte a aquellos docentes que deseen despertar
    el interÈs de sus alumnos sobre la programaciÛn con ejercicios m·s interactivos, los que a
    veces son presentados en las primeras etapas del estudio de fundamentos de programaciÛn.
    Como ya es habitual en SL, estas rutinas fueron cuidadosamente diseÒadas para que no
    tengan ning˙n efecto cuando la salida (o la entrada) es archivo y no la consola (pantalla y
    teclado), ya que no tiene sentido ìcambiar el color del textoî, por ejemplo, cuando
    imprimir() est· grabando en un archivo, en vez mostrar datos en la pantalla.
    Lo que sigue es un resumen de los cambios y adiciones, dando en cada caso el formato o
    prototipo del subprograma correspondiente.
    1. Cambiar la posiciÛn del cursor
    sub set_curpos (nueva_lin, nueva_col : numerico)
    Posiciona el cursor en la lÌnea y columna especificadas. La esquina superior izquierda de la
    pantalla corresponde a la posiciÛn (1, 1), es decir, lÌnea 1 columna 1. Si solo desea
    P·gina 5/14
    cambiarse la columna, conservando la fila actual, puede pasarse columna 0; similar efecto
    se logra pasando 0 como n˙mero de lÌnea: solo se cambia la columna.
    2. Obtener la posiciÛn del cursor
    sub get_curpos (ref lin_actual, col_actual : numerico)
    Cuenta la lÌnea y columna donde se encuentra actualmente el cursor. NÛtese que los dos
    par·metros que necesita esta rutina son pasados por referencia, es decir, deben ser
    nombres de variables numÈricas.
    3. Cambiar el color del texto impreso
    sub set_color (primer_plano, fondo : numerico)
    El segundo par·metro de set_color() indica el color de fondo que se desea, que va de 1 a 8,
    donde 1 generalmente es negro. El primer par·metro (primer_plano) indica el color del
    texto mismo, y puede ir de 1 a 16. Lo que sigue es un ejemplo:
    1. inicio
    2. set_color (1, 11)
    3. imprimir ("Este texto debe verse en color verde sobre negro")
    4. fin
    Si cualquiera de los par·metros es 0, el color correspondiente no se ve afectado.
    Por una decisiÛn de diseÒo, los colores no tienen nombres o significados predefinidos, ya
    que al hacerlo se est· limitando la posibilidad de portar SL a nuevas plataformas.
    4. Obtener el color del texto impreso
    sub get_color (ref primer_plano, fondo : numerico)
    Obtiene el color del texto y del fondo vigentes. NÛtese que ambos par·metros son pasados
    por referencia, por lo que se deben proveer el nombre de dos variables.
    5. Cambiar el color de fondo de toda la pantalla
    Este efecto se obtiene llamando primero a set_color(), seguido de cls().
    6. Obtener las dimensiones de la pantalla, en lÌneas y columnas.
    sub get_scrsize (ref cant_lin, cant_cols : numerico)
    Obtiene la cantidad de lÌneas y columnas que tiene la pantalla. NÛtese que ambos
    par·metros son pasados por referencia, por lo que se deben proveer el nombre de dos
    variables. El tamaÒo habitual de la pantalla es 25 lÌneas por 80 columnas.
    P·gina 6/14
    7. Esperar a que se pulse una tecla
    sub readkey (milisegundos : numerico) retorna numerico
    Espera a que se pulse una tecla y retorna un cÛdigo numÈrico que identifica lo pulsado por
    el usuario. El tiempo que se espera depende del par·metro, que est· en milisegundos.
    Si se omite el par·metro, readkey() espera indefinidamente a que el usuario pulse una
    tecla. De contrario esperar· el tiempo que se le indique (en milisegundos) y si nada se pulsÛ
    en ese tiempo, retornar· 0.
    Por una decisiÛn de diseÒo y portabilidad de SL, no se asigna ning˙n significado especÌfico
    al valor retornado por esta funciÛn, aunque el usuario es libre de experimentar y observar
    quÈ valores se generan para cada tecla.
    8. Emitir pitido
    sub beep (frecuencia, duracion_millis : numerico)
    Emite un pitido a cierta frecuencia y durante el tiempo que se indica en el segundo
    par·metro (expresado en milisegundos).
    Ambos par·metros pueden omitirse, en cuyo caso se utiliza autom·ticamente los valores
    (500, 100), es decir, se emite un pitido durante una dÈcima de segundo.
    NÛtese que beep() puede ser utilizado para introducir una pausa en la ejecuciÛn, sin
    emitir pitido propiamente. Por ejemplo beep(0, 5000) har· una pausa de medio
    segundo.
    5.5. EJEMPLO DE USO DE LA ENTRADA/SALIDA POR PANTALLA MEJORADAEJEMPLO DE USO DE LA ENTRADA/SALIDA POR PANTALLA MEJORADA
    El siguiente programa muestra el uso de las nuevas funciones de entrada/salida por
    pantalla. Despliega un texto deslizante, mientras muestra la hora actual. Termina cuando el
    usuario pulsa alguna tecla.
    OBSERVACI”N: Si quiere ver este programa funcionando, puede encontrar el programa
    compilado (ejecutable de consola de Win32) en ftp://ftp.cnc.una.py/pub/slc/test_reloj.exe
    1. /*
    2. * test_reloj.sl
    3. * (c) 2003, Juan Segovia
    4. *
    5. * Muestra el uso de algunas rutinas para cambiar color,
    6. * posicionar el cursor y leer directamente del teclado.
    7. *
    8. */
    9.
    10. const
    11. COLOR_blanco_fuerte = 16
    12. COLOR_azul = 2
    13. COLOR_blanco = 8
    P·gina 7/14
    14. COLOR_verde = 11
    15. COLOR_negro = 1
    16. inicio
    17. /*
    18. * Cambiar el color de fondo, que consiste en cambiar los colores y
    19. * luego limpiar la pantalla.
    20. */
    21. set_color (COLOR_blanco_fuerte, COLOR_azul)
    22. cls()
    23.
    24. set_color (COLOR_blanco_fuerte, COLOR_blanco)
    25. set_curpos (8, 20)
    26. imprimir (" Muestra el uso de colores y readkey() en SL ")
    27. demo()
    28. fin
    29.
    30.
    31. sub demo()
    32. var
    33. marq_msg = "Pulse alguna tecla para terminar...."
    34. marq_ancho_ventana = 80
    35. marq_col_actual = marq_ancho_ventana
    36. inicio
    37. repetir
    38. desplegar_marquesina (marq_msg, marq_ancho_ventana, marq_col_actual)
    39. desplegar_reloj()
    40.
    41. /*
    42. * Salir si se pulso alguna tecla.
    43. */
    44. hasta (readkey(100) > 0)
    45. fin
    46.
    47.
    48. sub desplegar_reloj()
    49. /*
    50. * Muestra la hora actual en formato HH:MM:SS
    51. *
    52. */
    53. var
    54. hh, mm, ss : numerico
    55. tiempo : numerico
    56. inicio
    57. tiempo = sec()
    58. hh = int(tiempo/ 3600)
    59. dec (tiempo, hh*3600)
    60. mm = int (tiempo / 60)
    61. ss = tiempo % 60
    62.
    63. set_curpos (10, 33)
    64.
    65. set_color (COLOR_blanco_fuerte, COLOR_azul)
    66. imprimir ( str (hh, 2, 0, '0'), ':',
    67. str (mm, 2, 0, '0'), ':',
    68. str (ss, 2, 0, '0')
    69. )
    70. fin
    71.
    72.
    73. sub desplegar_marquesina (msg : cadena; ancho_vent : numerico
    74. ref col_actual : numerico)
    75. /*
    76. * Muestra un texto en formato "marquesina", es decir, el texto
    77. * va apareciendo sucesivamente en la pantalla desde el borde
    78. * derecho y desaparece luego por la izquierda, repitiendose
    79. * sucesivamente esta secuencia.
    80. *
    81. * El parametro col_actual es fundamental que sea pasado por
    P·gina 8/14
    82. * referencia.
    83. *
    84. */
    85.
    86. var
    87. parte_msg : cadena
    88. len_msg = strlen (msg)
    89.
    90. const
    91. LINEA_marq = 11
    92.
    93. inicio
    94. si ( col_actual > 0 ) {
    95. set_curpos (LINEA_marq, col_actual)
    96. parte_msg = substr (msg, 1, ancho_vent-col_actual+1)
    97. sino
    98. set_curpos (LINEA_marq, 1)
    99. si ( col_actual == 0 ) {
    100. col_actual = -2
    101. }
    102. parte_msg = substr (msg, -col_actual)
    103. }
    104.
    105. set_color (COLOR_verde, COLOR_negro)
    106. imprimir (parte_msg)
    107.
    108. /*
    109. * Como se ha corrido el texto un lugar a la izquierda, debemos
    110. * tachar, con el color de fondo, el ultimo caracter del
    111. * despliegue previo.
    112. */
    113. set_color (COLOR_blanco_fuerte, COLOR_azul)
    114. imprimir (' ')
    115.
    116. /*
    117. * Cuando se hayan desplegado TODOS los caracteres, preparar
    118. * para que el mensaje reaparezca por la derecha.
    119. */
    120. si ( col_actual < -len_msg ) {
    121. col_actual = ancho_vent+1
    122. }
    123. dec (col_actual)
    124. fin
    6.6. NUEVOS OPERADORES L”GICOSNUEVOS OPERADORES L”GICOS
    Existen dos nuevos operadores lÛgicos, simbolizados por ì&&î y ì||î. Estos operadores son
    una variante de los operadores and y or respectivamente. La diferencia es que estos
    nuevos operadores realizan la evaluaciÛn en modo ìcorto-circuitoî, como se lo conoce
    tÈcnicamente. En este modo, una expresiÛn puede ser evaluada parcialmente, hasta que se
    conozca el valor final de la expresiÛn.
    Por ejemplo, si el lado izquierdo de una expresiÛn que involucra al operador and es falso,
    no tiene sentido evaluar el lado derecho, pues ya se sabe que la expresiÛn completa ser·
    falsa. Al disponer de los operadores && y || es posible escribir cÛdigo m·s compacto.
    Ejemplo: Determinar la posiciÛn de la primera apariciÛn de un valor en un arreglo.
    P·gina 9/14
    1. sub localizar_valor (v : numerico; A : vector [*] numerico) retorna numerico
    2. /*
    3. * Retorna la posición de la primera aparición de v en A. Si v no existe
    4. * en A, se retorna 0.
    5. */
    6. var
    7. g = alen(A)
    8. p = 0
    9. inicio
    10. p = 1
    11. mientras ( (p <= g) && (A [p] <> v) ) {
    12. inc (p)
    13. }
    14. /*
    15. * No se encontró v en A.
    16. */
    17. si ( p > g ) {
    18. p = 0
    19. }
    20. retorna p
    21. fin
    Si en la rutina localizar_valor() us·semos el operador and en vez de &&, se producirÌa un
    error de ejecuciÛn cuando v no se encuentre en A, pues A[p] accederÌa a una posiciÛn
    inexistente (uno m·s que la ˙ltima posiciÛn existente en A).
    Cuando las expresiones son anidadas (parentizadas, por ejemplo), los operadores && y ||
    realizan la evaluaciÛn en ìcorto-circuitoî de la subexpresiÛn en la que est·n inmersos, no
    de toda la expresiÛn.
    Como consecuencia de la introducciÛn de && y ||, los sÌmbolos & y | fueron retirados de
    SL, que anteriormente eran sinÛnimos de and y or respectivamente.
    En general, el uso de && y || producir· programas que se ejecuten ligeramente m·s
    r·pidos que los que se obtienen usando and y or.
    7.7. MEJORAS COMPLEMENTARIAS PARA LA ENTRADA/SALIDAMEJORAS COMPLEMENTARIAS PARA LA ENTRADA/SALIDA
    Se han introducido ligeros cambios en el comportamiento de algunas subrutinas
    incorporadas para mejorar y facilitar la entrada/salida. A continuaciÛn los detalles:
    1. Posibilidad de leer un archivo car·cter por car·cter
    Es posible leer un archivo car·cter a car·cter si se hace set_ifs(“”), es decir, si el
    par·metro es una cadena vacÌa. En este caso el car·cter separador de lÌnea se obtiene como
    un car·cter m·s.
    Esta funcionalidad puede ser ˙til, por ejemplo, para escribir un analizador lexicogr·fico ,
    que es un componente cl·sico de un compilador.
    Por otra parte, set_ifs() debe ser llamado luego de cada set_stdin(), pues se
    restaura a su valor original (“,”) al cambiar el archivo de entrada.
    P·gina 10/14
    2. Las lecturas parciales no generan error
    Si una operaciÛn de lectura no encuentra suficientes datos para todas las variables, no se
    genera un error de ejecuciÛn, a diferencia de versiones previas de SL. Simplemente se activa
    el indicador de fin de archivo, que puede averiguarse llamando a la funciÛn eof(). Este
    cambio posibilita que el siguiente fragmento de cÛdigo funcione como se espera:
    1. /*
    2. * Cuenta la cantidad de líneas que existen en el archivo poesia.txt
    3. *
    4. * Observacion: No verifica si el archivo poesia.txt existe o si pudo
    5. * abrirse.
    6. */
    7. var
    8. linea = ""
    9. cant_lineas = 0
    10. inicio
    11. set_stdin ("poesia.txt")
    12. set_ifs ("\n")
    13. leer (linea)
    14. mientras ( not eof() ) {
    15. inc (cant_lineas)
    16. leer (linea)
    17. }
    18. imprimir ("\nFueron leídas ", cant_lineas, " líneas\n")
    19. fin
    3. Especificador de separador de valores de datos estructurados
    sub set_ofs (s : cadena)
    La rutina set_ofs() sirve para configurar quÈ car·cter utilizar· imprimir() para
    separar los valores de los datos compuestos, como los registros y arreglos. Por defecto este
    car·cter es una coma.
    Adem·s del car·cter separador de valores set_ofs() configura lo que se mostrar·
    cuando imprimir() encuentre un arreglo que no est· dimensionado. Por defecto se imprime
    ì<nodim>î.
    El primer car·cter del par·metro de set_ofs() es el separador y lo que sigue es el
    indicador de ìno dimensionadoî, por lo que la configuraciÛn por defecto act˙a como si se
    hubiese hecho set_ofs(“,<nodim>”).
    Para obtener estos valores vigentes se usa get_ofs(), cuyo prototipo es:
    sub get_ofs (s : cadena) retorna cadena
    8.8. MAYOR LEGIBILIDAD DE LAS CONSTANTES LITERALES NUM…RICASMAYOR LEGIBILIDAD DE LAS CONSTANTES LITERALES NUM…RICAS
    Para facilitar la legibilidad de los programas, los valores enteros que aparezcan literalmente
    en el programa fuente (es decir, constantes literales numÈricas) pueden llevar un guiÛn bajo
    como un dÌgito ìmudoî. Por ejemplo, cada una de las siguientes lÌneas contiene el n˙mero
    P·gina 11/14
    un millÛn (si bien la segunda forma es la que resulta m·s simple de leer):
    1000000
    1_000_000
    10_000_00
    100_000_0
    El guiÛn bajo puede aparecer luego de un car·cter, es decir, el literal no puede empezar
    con un guiÛn. La parte fraccionaria y el exponente de la notaciÛn cientÌfica tambiÈn pueden
    usar el guiÛn bajo.
    9.9. OTROS CAMBIOS M¡S PEQUE—OSOTROS CAMBIOS M¡S PEQUE—OS
    1. sub como sinÛnimo de subrutina
    Dado que la palabra ìsubrutinaî es usada a menudo, se introdujo la abreviatura ìsubî. Esta
    nueva forma la hemos utilizado a lo largo de los ejemplos de este documento.
    2. Sintaxis del valor de retorno de las funciones
    En versiones previas de SL era necesario parentizar la expresiÛn que definÌa el valor de
    retorno de las funciones; tal requerimiento sint·ctico fue eliminado, si bien quienes lo
    prefieran pueden seguir parentizando las expresiones.
    En SL las expresiones que indican o provocan ejecuciÛn condicional llevan parÈntesis. Tal es
    el caso de mientras, si, repetir..hasta, eval..caso. Dado que retorna
    no un especificador de ejecuciÛn condicional, no debe ser obligatorio que lleve parÈntesis.
    3. TerminaciÛn anticipada de la ejecuciÛn del programa
    Se agregÛ la subrutina terminar() que provoca la terminaciÛn de la ejecuciÛn del
    programa. Esto es ˙til cuando se detecta una condiciÛn que imposibilita seguir ejecutando
    el programa, por ejemplo, cuando no se pudo abrir el archivo de entrada indicado por el
    usuario.
    El prototipo de terminar() es
    sub termin (msg : cadena)
    donde el par·metro msg especifica un mensaje que se imprimir· antes de que termine la
    ejecuciÛn. Este par·metro es opcional; si no se especifica nada, se asume ìî.
    Ampliaremos el ejemplo previo del contador de lÌneas de texto de un archivo para mostrar
    el uso de terminar().
    1. /*
    2. * Cuenta la cantidad de líneas que existen en el archivo poesia.txt
    3. * Verifica si el archivo poesia.txt existe o si pudo
    4. * abrirse.
    5. */
    P·gina 12/14
    6.
    7. var
    8. linea = ""
    9. cant_lineas = 0
    10. inicio
    11. /*
    12. * Verificar si el archivo pudo abrirse. En tal caso, set_stdin()
    13. * retorna verdadero.
    14. */
    15. si ( not set_stdin ("poesia.txt") ) {
    16. imprimir ("\nNo se pudo abrir el archivo poesia.txt\n",
    17. "El programa no puede continuar.")
    18. terminar("\nEjecución terminada.\n")
    19. /*
    20. * Lo que sigue NUNCA se hará, pues la rutina termin() NUNCA
    21. * retorna.
    22. */
    23. linea = "--nunca llega aquí--"
    24. }
    25. set_ifs ("\n")
    26. leer (linea)
    27. mientras ( not eof() ) {
    28. inc (cant_lineas)
    29. leer (linea)
    30. }
    31. imprimir ("\nFueron leídas ", cant_lineas, " líneas\n")
    32. fin
    NÛtese que terminar() es sint·cticamente una subrutina pero no se comporta como tal
    pues NUNCA retorna. En el ejemplo, la lÌnea 23 jam·s se ejecutar·.
    4. EjecuciÛn de programas externos
    Se agregÛ la funciÛn runcmd() que ejecuta un programa externo cualquiera. El prototipo
    de esta funciÛn es:
    sub runcmd (cmd : cadena) retorna numerico
    El siguiente fragmento de cÛdigo muestra cÛmo se podrÌa usar runcmd().
    1. /*
    2. * Observacion: Este no es un programa SL completo.
    3. */
    4. inicio
    5. rumcmd ("miejec.exe " + " param1 param2")
    6. ...
    7. ...
    8. fin
    El par·metro pasado a runcmd() incluye el nombre del comando y los argumentos que
    Èste necesite. La ejecuciÛn del comando se realiza vÌa el procesador de comandos del
    usuario y las reglas de localizaciÛn del comando externo son las de aquel.
    El valor de retorno de runcmd() es el valor de salida del comando ejecutado. Pero si la
    ejecuciÛn del comando no puede realizarse, runcmd() retorna 127. (NÛtese que este
    valor es arbitrario y bien podrÌa ser que un comando se ejecute correctamente y retorne
    127).
    P·gina 13/14
    5. Las funciones min() y max()
    La nueva funciÛn min() retorna el menor de dos valores que se le pasa como par·metro,
    mientras que max() retorna el mayor. Ambas funciones pueden operar sobre cualquier
    tipo b·sico (cadena, numerico, logico). Sin embargo, ambos par·metros deben
    coincidir en tipo, ya que no tiene sentido encontrar el mayor de una cadena y un n˙mero,
    por ejemplo.
    El siguiente ejemplo muestra el uso de max() para identificar el mayor de 3 n˙meros.
    1. /*
    2. * Lee 3 números e imprime el mayor de ellos.
    3. */
    4. var
    5. a, b, c : numerico
    6. inicio
    7. imprimir ("\nIngrese tres valores numéricos: ")
    8. leer (a, b, c)
    9. si ( a == b && b == c ) {
    10. imprimir ("\nLos tres números ingresados son iguales")
    11. sino
    12. imprimir ("\nEl mayor es ", max (max (a, b), c), "\n")
    13. }
    14. fin
    10.10.DISPONIBILIDAD DE ESTAS MEJORASDISPONIBILIDAD DE ESTAS MEJORAS
    Las caracterÌsticas presentadas en este documento est·n incorporadas en SLE (VersiÛn
    Windows) de fecha 24-feb-2003 o posterior. Puede acceder al Ìtem ìAcerca del
    compiladorî en SLE para verificar quÈ versiÛn est· utilizando. Si no tiene la versiÛn
    apropiada, puede descargarla de
    ftp://ftp.cnc.una.py/pub/slc
    Por otra parte, en breve encontrar· en esta direcciÛn versiones del entorno de desarrollo
    para Linux y para Windows, en ambiente gr·fico.
    AGRADECIMIENTOAGRADECIMIENTO
    El autor agradece a Blanca de Trevisan, Cristian Cappo, Cristina Paiva, Pablo Greenwood y Rolando
    Chaparro, quienes cooperaron en la revisión de este documento.
    P·gina 14/14
</p>